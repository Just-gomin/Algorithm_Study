/*
    # 문제 해결 단서
    0. 입력 형식 : a ( n개의 풍선, 1 <= n <= 1000000, n개의 풍선에는 서로 다른 숫자가 써져 있습니다.)
    1. 인접한 풍선 중 한개를 터트리고, 빈 공간이 없게 풍선을 밀착 시킵니다.
    2. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 가능합니다.
        - 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트리면, 그 이후에는 더 큰 풍선들만을 터트릴 수 있습니다.
    3. 어떤 풍선을 최후까지 살아 남을 수도 있지만, 어떤 풍선은 무슨 수를 써도 마지막 까지 남는 것이 불가능할 수도 있습니다.
    4. 위의 규칙대로 터트리기를 진행 했을 때, 최후에 남는 것이 가능한 풍선들의 개수를 반환합니다.
    
    # 문제 해결 방안
    1. 현재 숫자와 양 옆의 수를 먼저 비교하여, 이 둘이 모두 작다면 해당 숫자는 마지막까지 남을 수 없기에 해당 경우 이외에 검사를 진행합니다.
    2. 좌측의 최소치는 반복문을 진행하며 갱신할 수 있고, 우측의 최소치는 진행을 하며, 해당 숫자와 우측의 최소치가 같을 때 갱신을 합니다.
    3. 양측의 최소치들과 현재의 숫자를 비교해 둘 모두 현재 숫자보다 작은경우가 아니라면 끝까지 살아남을 수 있습니다.

    # 
    해당 방법은 O(n^2)으로 실행되고 있습니다. 해당 문제는 O(n)의 시간복잡도를 요구하고 있는 것 같기에 좀더 개선이 필요합니다.
*/

const solution = (a = []) => {
  if (a.length === 1) return 1;

  let result = 0;

  let lmin = a[0];
  let rmin = Math.min(...a);

  for (let i = 0; i < a.length; i += 1) {
    if (i == 0 || i == a.length - 1) result += 1;
    else if (a[i] <= a[i - 1] || a[i] <= a[i + 1]) {
      if (lmin > a[i - 1]) lmin = a[i - 1];
      if (a[i] === rmin) {
        rmin = Math.min(...a.slice(i + 1, a.length));
        result += 1;
      } else if (lmin >= a[i] || rmin >= a[i]) result += 1;
    }
  }

  return result;
};

let example1 = [9, -1, -5]; //result : 3
let example2 = [-16, 27, 65, -2, 58, -92, -71, -68, -61, -33]; // result : 6

console.log(solution(example1));
console.log(solution(example2));
